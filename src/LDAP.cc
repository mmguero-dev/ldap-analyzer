// Generated by binpac_quickstart

#include "LDAP.h"
#include "analyzer/protocol/tcp/TCP_Reassembler.h"
#include "Reporter.h"
#include "types.bif.h"
#include "events.bif.h"

using namespace analyzer::LDAP;

LDAP_Analyzer::LDAP_Analyzer(zeek::Connection* c)

: zeek::analyzer::tcp::TCP_ApplicationAnalyzer("LDAP", c)

	{
	interp = new binpac::LDAP::LDAP_Conn(this);
	had_gap = false;

	endp_orig.building_packet = false;
	endp_orig.ldap_buf_len = 0;
	endp_orig.processed_len = 0;
	endp_orig.ldap_buf = NULL;

	endp_resp.building_packet = false;
	endp_resp.ldap_buf_len = 0;
	endp_resp.processed_len = 0;
	endp_resp.ldap_buf = NULL;

	packet_counter = 0;
	}

LDAP_Analyzer::~LDAP_Analyzer()
	{
	delete interp;
	if(endp_orig.ldap_buf != NULL)  {
	    free(endp_orig.ldap_buf);
	    endp_orig.ldap_buf = NULL;
	}
	if(endp_resp.ldap_buf != NULL)  {
	    free(endp_resp.ldap_buf);
	    endp_resp.ldap_buf = NULL;
	}
	}

void LDAP_Analyzer::Done()
	{
	zeek::analyzer::tcp::TCP_ApplicationAnalyzer::Done();

	interp->FlowEOF(true);
	interp->FlowEOF(false);
	}

void LDAP_Analyzer::EndpointEOF(bool is_orig)
	{
	zeek::analyzer::tcp::TCP_ApplicationAnalyzer::EndpointEOF(is_orig);

	interp->FlowEOF(is_orig);
	}

void LDAP_Analyzer::DeliverStream(int len, const u_char* data, bool orig)
	{
	zeek::analyzer::tcp::TCP_ApplicationAnalyzer::DeliverStream(len, data, orig);

	Endpoint *endp_p = NULL;


	assert(TCP());
	if ( TCP()->IsPartial() )  {
		return;
	}

	if ( had_gap )  {
		// If only one side had a content gap, we could still try to
		// deliver data to the other side if the script layer can handle this.
		return;
	}

	if(orig)  {
	    endp_p = &endp_orig;
	}
	else  {
	    endp_p = &endp_resp;
	}

	if(!(endp_p->building_packet))  {
	    // first packet, so need to get length and malloc our ldap buffer
	    int64_t length;

	    if(data[0] == 0x00)  {
	        // GSSAPI header before LDAP message
	        int gssapi_len = 0;
	        for(int i=0; i<4; i++)  {
	            unsigned char byte = data[i];
	            gssapi_len |= byte << (8 * (4 - (i + 1)));
	        }

	        endp_p->ldap_buf_len = gssapi_len + 4;
	    }
	    else  {
	        // no GSSAPI header before, so data is the start of ldap (0x30)
	        endp_p->ldap_buf_len += 2;  // for tag and len

	        // ASN1 length calculation
                uint8_t len_meta = (uint8_t)data[1];
                unsigned char *more_len;
                if((len_meta & 0x80) > 0)  {
                    more_len = (unsigned char*)malloc(len_meta & 0x7f);
                    for(int i=0; i<(len_meta & 0x7f); i++)  {
                        more_len[i] = data[2+i];
                    }

                    endp_p->ldap_buf_len += len_meta & 0x7f;

                    int64_t rval = 0;
                    for(int i=0; i<(len_meta & 0x7f); i++)  {
                        uint64_t byte = more_len[i];
                        rval |= byte << (8 * (len_meta - (i + 1)));
                    }

                    endp_p->ldap_buf_len += rval;
                    free(more_len);
                }
                else  {
                    endp_p->ldap_buf_len += len_meta;
                }
	    }

	    endp_p->ldap_buf = (unsigned char*)malloc(endp_p->ldap_buf_len);
	    endp_p->building_packet = true;
	}

	if(len > endp_p->ldap_buf_len - endp_p->processed_len)  {
	    // TODO handle this instead of just return
	    return;
	}

	memcpy(endp_p->ldap_buf + endp_p->processed_len, data, len);
	endp_p->processed_len += len;

	if(endp_p->processed_len == endp_p->ldap_buf_len)  {
	    // done getting data, let's analyze!

	    try
		{
		    interp->NewData(orig, endp_p->ldap_buf, endp_p->ldap_buf + endp_p->ldap_buf_len);
		}
	    catch ( const binpac::Exception& e )
		{
		    ProtocolViolation(zeek::util::fmt("Binpac exception: %s", e.c_msg()));
		}

	    if(endp_p->ldap_buf != NULL)  {
                free(endp_p->ldap_buf);
                endp_p->ldap_buf = NULL;
            }
            endp_p->building_packet = false;
	    endp_p->processed_len = 0;
	    endp_p->ldap_buf_len = 0;
	    packet_counter++;
	}
	}

void LDAP_Analyzer::Undelivered(uint64_t seq, int len, bool orig)
	{
	zeek::analyzer::tcp::TCP_ApplicationAnalyzer::Undelivered(seq, len, orig);

	had_gap = true;
	interp->NewGap(orig, len);
	}
